#ifndef SORBET_PARSER_PRISM_TRANSLATOR_H
#define SORBET_PARSER_PRISM_TRANSLATOR_H

#include "absl/types/span.h"
#include "core/errors/parser.h"
#include "parser/Node.h" // To clarify: these are Sorbet Parser nodes, not Prism ones.
#include "parser/prism/Parser.h"
#include <memory>
#include <optional>

extern "C" {
#include "prism.h"
}

namespace sorbet::parser::Prism {

// namespace core = ::sorbet::core; // Removed alias

class Translator final {
    const Parser &parser;
    // This context holds a reference to the GlobalState allocated up the call stack, which is why we don't allow
    // Translator objects to be copied or moved.
    ::sorbet::core::MutableContext ctx;

    // The errors that were found by Prism during parsing
    const absl::Span<const ParseError> parseErrors;

    // Whether to directly desugar during in the Translator, or wait until the usual `Desugar.cc` code path.
    const bool directlyDesugar;

    // When true, desugar less aggressively so that refactoring actions operate on the code that was actually written,
    // instead of synthetic code that was generated by the desugarer.
    const bool preserveConcreteSyntax;

    // Unique counters used to create synthetic names via `ctx.state.freshNameUnique`.
    // - The storage integers either store an "active" count used by a translator and some of its children,
    //   or a dummy value.
    // - The pointer variables point to the "active" count for each translator,
    //   which is either pointing to its own storage, or to a parent's storage.
    uint16_t parserUniqueCounterStorage;  // Minics the `Builder::Impl.uniqueCounter_` in `parser/Builder.cc`
    uint32_t desugarUniqueCounterStorage; // Minics the `DesugarContext.uniqueCounter`  in `ast/desugar/Desugar.cc`
    uint16_t &parserUniqueCounter;        // Points to the active `parserUniqueCounterStorage`
    uint32_t &desugarUniqueCounter;       // Points to the active `desugarUniqueCounterStorage`

    // Context variables
    const ::sorbet::core::LocOffsets enclosingMethodLoc;   // The location of the method we're in, or `none()`
    const ::sorbet::core::NameRef enclosingMethodName;     // The name of the method we're in, or `noName()`
    const ::sorbet::core::NameRef enclosingBlockParamName; // The name of the block param of the method we're in, or `noName()`
    const bool isInModule = false;   // True if we're in a Module definition. False for classes and singleton classes
    const bool isInAnyBlock = false; // True if we're in a `{ }`/`do end` block

    Translator(Translator &&) = delete;                 // Move constructor
    Translator(const Translator &) = delete;            // Copy constructor
    Translator &operator=(Translator &&) = delete;      // Move assignment
    Translator &operator=(const Translator &) = delete; // Copy assignment
public:
    Translator(const Parser &parser, ::sorbet::core::MutableContext ctx, const absl::Span<const ParseError> parseErrors,
               bool directlyDesugar, bool preserveConcreteSyntax)
        : parser(parser), ctx(ctx), parseErrors(parseErrors), directlyDesugar(directlyDesugar),
          preserveConcreteSyntax(preserveConcreteSyntax), parserUniqueCounterStorage(1), desugarUniqueCounterStorage(1),
          parserUniqueCounter(this->parserUniqueCounterStorage),
          desugarUniqueCounter(this->desugarUniqueCounterStorage) {}

    // Translates the given AST from Prism's node types into the equivalent AST in Sorbet's legacy parser node types.
    std::unique_ptr<::sorbet::parser::Node> translate(pm_node_t *node);

private:
    // This private constructor is used for creating child translators with modified context.
    // uniqueCounterStorage is passed as a dummy value and is never used
    Translator(const Translator &parent, bool resetDesugarUniqueCounter, ::sorbet::core::LocOffsets enclosingMethodLoc,
               ::sorbet::core::NameRef enclosingMethodName, ::sorbet::core::NameRef enclosingBlockParamName, bool isInModule,
               bool isInAnyBlock)
        : parser(parent.parser), ctx(parent.ctx), parseErrors(parent.parseErrors),
          directlyDesugar(parent.directlyDesugar), preserveConcreteSyntax(parent.preserveConcreteSyntax),
          parserUniqueCounterStorage(9999), desugarUniqueCounterStorage(resetDesugarUniqueCounter ? 1 : 999999),
          parserUniqueCounter(parent.parserUniqueCounter),
          desugarUniqueCounter(resetDesugarUniqueCounter ? this->desugarUniqueCounterStorage
                                                         : parent.desugarUniqueCounter),
          enclosingMethodLoc(enclosingMethodLoc), enclosingMethodName(enclosingMethodName),
          enclosingBlockParamName(enclosingBlockParamName), isInModule(isInModule), isInAnyBlock(isInAnyBlock) {}

    template <typename SorbetNode, typename... TArgs>
    std::unique_ptr<::sorbet::parser::Node> make_node_with_expr(::sorbet::ast::ExpressionPtr desugaredExpr, TArgs &&...args) const;

    template <typename SorbetNode, typename... TArgs>
    std::unique_ptr<::sorbet::parser::Node> make_unsupported_node(TArgs &&...args) const;

    ::sorbet::core::LocOffsets translateLoc(pm_location_t loc) const;
    ::sorbet::core::LocOffsets translateLoc(const uint8_t *start, const uint8_t *end) const;

    ::sorbet::parser::NodeVec translateMulti(pm_node_list prismNodes);
    void translateMultiInto(::sorbet::parser::NodeVec &sorbetNodes, absl::Span<pm_node_t *> prismNodes);

    std::pair<std::unique_ptr<::sorbet::parser::Params>, ::sorbet::core::NameRef /* enclosingBlockParamName */>
    translateParametersNode(pm_parameters_node *paramsNode, ::sorbet::core::LocOffsets location);

    std::tuple<::sorbet::ast::MethodDef::PARAMS_store, ::sorbet::ast::InsSeq::STATS_store, bool>
    desugarParametersNode(::sorbet::parser::NodeVec &params, bool attemptToDesugarParams);

    ::sorbet::core::LocOffsets findItParamUsageLoc(pm_statements_node *statements);

    std::array<::sorbet::core::LocOffsets, 9> findNumberedParamsUsageLocs(::sorbet::core::LocOffsets loc, pm_statements_node *statements,
                                                                uint8_t maxParamNumber);

    ::sorbet::parser::NodeVec translateNumberedParametersNode(pm_numbered_parameters_node *numberedParamsNode,
                                            pm_statements_node_t *statements,
                                            ::sorbet::ast::MethodDef::PARAMS_store *paramsStore);

    ::sorbet::ast::ExpressionPtr desugarSymbolProc(pm_symbol_node *symbol);

    ::sorbet::parser::NodeVec translateArguments(pm_arguments_node *node, pm_node *blockArgumentNode = nullptr);
    ::sorbet::parser::NodeVec translateKeyValuePairs(pm_node_list_t elements);

    ::sorbet::ast::ExpressionPtr desugarArray(::sorbet::core::LocOffsets location, absl::Span<pm_node_t *> prismElements,
                                    ::sorbet::ast::Array::ENTRY_store elements);
    ::sorbet::ast::ExpressionPtr desugarHash(::sorbet::core::LocOffsets loc, ::sorbet::parser::NodeVec &kvPairs);

    std::unique_ptr<::sorbet::parser::Node> translateCallWithBlock(pm_node_t *prismBlockOrLambdaNode,
                                                         std::unique_ptr<::sorbet::parser::Node> sendNode);

    ::sorbet::parser::NodeVec translateEnsure(pm_begin_node *beginNode);
    std::unique_ptr<::sorbet::parser::Node> translateRescue(pm_begin_node *parentBeginNode);
    std::unique_ptr<::sorbet::parser::Node> translateStatements(pm_statements_node *stmtsNode, bool inlineIfSingle = true,
                                                      ::sorbet::core::LocOffsets overrideLocation = ::sorbet::core::LocOffsets::none());

    std::unique_ptr<::sorbet::parser::Node> translateRegexpOptions(pm_location_t closingLoc);
    std::unique_ptr<::sorbet::parser::Node> translateRegexp(::sorbet::core::LocOffsets location, ::sorbet::core::LocOffsets contentLoc,
                                                  pm_string_t content, pm_location_t closingLoc);

    template <typename PrismNode>
    std::unique_ptr<::sorbet::parser::Mlhs> translateMultiTargetLhs(PrismNode *node, ::sorbet::core::LocOffsets location);

    template <typename PrismAssignmentNode, typename SorbetLHSNode>
    std::unique_ptr<::sorbet::parser::Node> translateAssignment(pm_node_t *node);

    template <typename PrismAssignmentNode, typename SorbetAssignmentNode, typename SorbetLHSNode>
    std::unique_ptr<::sorbet::parser::Node> translateAnyOpAssignment(PrismAssignmentNode *node, ::sorbet::core::LocOffsets location,
                                                           std::unique_ptr<::sorbet::parser::Node> lhs);

    // Translate operator assignment targeting an indexed expression (e.g., `a[0] += 1`).
    template <typename PrismAssignmentNode, typename SorbetAssignmentNode>
    std::unique_ptr<::sorbet::parser::Node> translateIndexAssignment(pm_node_t *node, ::sorbet::core::LocOffsets location);

    // Translate AndAsgn/OrAsgn operator assignments (e.g., `x &&= y`, `x ||= y`).
    template <typename SorbetAssignmentNode>
    std::unique_ptr<::sorbet::parser::Node> translateAndOrAssignment(::sorbet::core::LocOffsets location, std::unique_ptr<::sorbet::parser::Node> lhs,
                                                           std::unique_ptr<::sorbet::parser::Node> rhs);

    template <typename PrismConstantNode, typename SorbetAssignmentNode>
    std::unique_ptr<::sorbet::parser::Node> translateConstantAssignment(pm_node_t *node, ::sorbet::core::LocOffsets location);

    // Translate a constant path assignment, e.g. `A::B = 1`
    template <typename PrismConstantPathNode, typename SorbetAssignmentNode>
    std::unique_ptr<::sorbet::parser::Node> translateConstantPathAssignment(pm_node_t *node, ::sorbet::core::LocOffsets location);

    // Translates regular assignments, not including e.g. `x[i] = y`, `x &&= y`, `x ||= y`, etc.
    template <typename PrismVariableNode, typename SorbetAssignmentNode, typename SorbetLHSNode>
    std::unique_ptr<::sorbet::parser::Node> translateVariableAssignment(pm_node_t *node, ::sorbet::core::LocOffsets location);

    // Translates an assignment to a method call, e.g. `x.y = z`
    template <typename PrismAssignmentNode, typename SorbetAssignmentNode>
    std::unique_ptr<::sorbet::parser::Node> translateSendAssignment(pm_node_t *node, ::sorbet::core::LocOffsets location);

    // Translate operator assignment targeting a safe navigation call (e.g., `a&.b += 1`).
    template <typename PrismAssignmentNode, typename SorbetAssignmentNode>
    std::unique_ptr<::sorbet::parser::Node> translateCSendAssignment(PrismAssignmentNode *callNode, ::sorbet::core::LocOffsets location,
                                                           std::unique_ptr<::sorbet::parser::Node> receiver, ::sorbet::core::NameRef name,
                                                           ::sorbet::core::LocOffsets messageLoc);

    template <typename PrismLhsNode, typename SorbetLHSNode, bool checkForDynamicConstAssign = false>
    std::unique_ptr<::sorbet::parser::Node> translateConst(PrismLhsNode *node);
    ::sorbet::core::NameRef translateConstantName(pm_constant_id_t constantId);

    // Generates a unique name for a `::sorbet::parser::Node`.
    ::sorbet::core::NameRef nextUniqueParserName(::sorbet::core::NameRef original);

    // Generates a unique name for a directly desugared `::sorbet::ast::ExpressionPtr`.
    ::sorbet::core::NameRef nextUniqueDesugarName(::sorbet::core::NameRef original);

    // Structure for holding the scaffolding needed for op-assignment desugaring
    struct OpAsgnScaffolding {
        ::sorbet::core::NameRef temporaryName;
        ::sorbet::ast::InsSeq::STATS_store statementBody;
        uint16_t numPosArgs;
        ::sorbet::ast::Send::ARGS_store readArgs;
        ::sorbet::ast::Send::ARGS_store assgnArgs;
    };

    // Copy arguments in op-assignment desugaring
    OpAsgnScaffolding copyArgsForOpAsgn(::sorbet::ast::Send *s);

    // Translate OpAsgn operator assignments
    template <typename SorbetAssignmentNode, typename PrismAssignmentNode>
    std::unique_ptr<::sorbet::parser::Node> translateOpAssignment(PrismAssignmentNode *node, ::sorbet::core::LocOffsets location,
                                                        std::unique_ptr<::sorbet::parser::Node> lhs,
                                                        std::unique_ptr<::sorbet::parser::Node> rhs);

    // Pattern-matching
    // ... variations of the main translation functions for pattern-matching related nodes.
    std::unique_ptr<::sorbet::parser::Node> patternTranslate(pm_node_t *node);
    ::sorbet::parser::NodeVec patternTranslateMulti(pm_node_list prismNodes);
    void patternTranslateMultiInto(::sorbet::parser::NodeVec &sorbetNodes, absl::Span<pm_node_t *> prismNodes);

    std::string_view sliceLocation(pm_location_t loc) const;

    // Helper function for creating if nodes with optional desugaring
    std::unique_ptr<::sorbet::parser::Node> translateIfNode(::sorbet::core::LocOffsets location, std::unique_ptr<::sorbet::parser::Node> predicate,
                                                  std::unique_ptr<::sorbet::parser::Node> ifTrue,
                                                  std::unique_ptr<::sorbet::parser::Node> ifFalse);

    std::pair<::sorbet::core::NameRef, ::sorbet::core::LocOffsets> translateSymbol(pm_symbol_node *symbol);

    // String interpolation desugaring
    sorbet::ast::ExpressionPtr desugarDString(::sorbet::core::LocOffsets loc, pm_node_list prismNodeList);

    // Multi-assignment desugaring
    ::sorbet::ast::ExpressionPtr desugarMlhs(::sorbet::core::LocOffsets loc, ::sorbet::parser::Mlhs *lhs, ::sorbet::ast::ExpressionPtr rhs);

    // Extracts the desugared expressions out of a "scope" (class/sclass/module) body.
    std::optional<::sorbet::ast::ClassDef::RHS_store> desugarScopeBodyToRHSStore(pm_node *prismBodyNode,
                                                                       std::unique_ptr<::sorbet::parser::Node> &scopeBody);

    void reportError(::sorbet::core::LocOffsets loc, const std::string &message) const;

    // Helper to determine whether to use super or untypedSuper based on context
    ::sorbet::core::NameRef maybeTypedSuper() const;

    // Context management helpers. These return a copy of `this` with some change to the context.
    bool isInMethodDef() const;
    Translator enterMethodDef(bool isSingletonMethod, ::sorbet::core::LocOffsets methodLoc, ::sorbet::core::NameRef methodName,
                              ::sorbet::core::NameRef enclosingBlockParamName) const;
    Translator enterBlockContext() const;
    Translator enterModuleContext() const;
    Translator enterClassContext() const;
};

} // namespace parser::Prism
#endif // SORBET_PARSER_PRISM_TRANSLATOR_H
